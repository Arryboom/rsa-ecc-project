/*
 * RSA.ECC Assignment 1, FIT5037, Sem 2, 2011
 * By Mark Culhane, 22471634
 */
package ECC;

import java.math.BigInteger;
import java.util.ArrayList;

/**
 * ECC messages are different from RSA messages :(
 * Collaborates with ECC Controller    
 * @author Mark Culhane, 22471634
 */
public class Message {
    
    //instance variables
    private String messageString;
    private String mX;
    private String mY;
    private BigInteger messagePointVal;
    private ArrayList cypherPoint;
    private ArrayList publicKey;
    private String decMessage; //chunks separated by delimeter
    private int chunkLength;
   
     /*    
     * Message Constructor
     * @param String incomming Message
     * @param ArrayList messagePoint is generated by the senders curve object
     * @param ArrayList cypherPoint is generated by the senders curve object
     * @param ArrayList publicKey is generated by the senders curve object
     */
    public Message(String incomingMessage, ArrayList messagePoint, ArrayList cypherPoint, ArrayList publicKey) {
        messageString = incomingMessage;
        mX = messagePoint.get(0).toString();
        mY = messagePoint.get(1).toString();
        String mPTemp = mX + mY;
        this.messagePointVal = new BigInteger(mPTemp);
        this.cypherPoint = cypherPoint;
        this.publicKey = publicKey;
        chunkLength = 20; //two letters per chunk, means that cyphertext.length > message(letter).length
        this.decMessage = buildDecMessage();
    }
    
     /*    
     * Message Alternate Constructor
     */

    public Message(String incomingMessage, BigInteger messagePointVal) {
        this.decMessage = incomingMessage;
        this.messagePointVal = messagePointVal;
        this.publicKey = null;
        this.messageString = "";
        this.chunkLength = Integer.parseInt(decMessage.substring(0, 3));
        chunkLength = chunkLength - 100;
    }

    
    
    /**
     * buildDecMessage encodes string message to BigInteger value using ASCII dec
    */
    public void revertDecMessage() {
        int i = 4;
        int letter;
        while (decMessage.charAt(i) != ')') {
            i++;
        }
        String workingMessage = decMessage.substring(i + 1);
        System.out.println("DecMessage to decrypt: " + workingMessage.toString());
        StringBuilder sb = new StringBuilder();
        BigInteger holder;
        i = 0;
        int k;
        do {
            k = i;
            while (workingMessage.charAt(k) != 'o') {
                k++;
            }
            holder = new BigInteger(workingMessage.substring(i, k));
            
            //System.out.println("Holder: " + holder.toString());
            //System.out.println("Message Point Val: " + messagePointVal.toString());
            
            holder = holder.subtract(messagePointVal);
            for (int j = 0; (j < (holder.toString().length())); j = j+3) {
                letter = Integer.parseInt(holder.toString().substring(j, j + 3));
                letter = letter - 100;
                sb.append(((char) letter));                
            }
            i = k + 3; //skip delimeter

        } while (workingMessage.charAt(i) != '>');
        messageString = sb.toString();
    }

    /**
     * buildDecMessage encodes string message to BigInteger value using ASCII dec
     * @return String decimal encoded, segmented message
    */
    private String buildDecMessage() {
        StringBuilder sb = new StringBuilder();
        //ensure first 3 digits indicate segmentSize
        sb.append(chunkLength + 100); 
        sb.append("(").append(cypherPoint.get(0)).append(",").append(cypherPoint.get(1)).append(")");
        sb.append(encodeASCIIECC());
        sb.append(">:D"); //delimeter
        return sb.toString();
    }
   
    /**
     * encodeASCII encodes string message to BigInteger value using ASCII dec
     * @return String chunk of dec message referenced to message point
    */
    private String encodeASCIIECC() {
        StringBuilder cypherBuild = new StringBuilder();
        StringBuilder sb = new StringBuilder();
        int charVal = 0;
        int i = 0;
        int k = 0;
        while (i < messageString.length()) {    
            
            while ((i < (k + (chunkLength/3))) && messageString.length() > i) {
                charVal = (int)messageString.charAt(i);
                charVal = charVal + 100; //ensure 3 digits
                sb.append(charVal);
                i = i + 1;
            }
            k = i;
            BigInteger cypherVal = new BigInteger(sb.toString());
            cypherBuild.append(cypherVal.add(messagePointVal));
            cypherBuild.append("o_O");
            sb.delete(0, (sb.length()));
        }
        return cypherBuild.toString() ;
   }
    
    /**
     * Get the decMessage of Message obj
     * @return String decMessage
     */
    public String getDecMessage() {
        return decMessage;
    }
    
    /**
     * Set the decMessage and updates stringMessage to match
     * @param String incoming decMessage
     */
    public void setDecMessage(String incomingDec) {
        decMessage = incomingDec;
    }
    
    /**
     * Get the Message String of Message obj
     * @return String messageString
     */
    public String getStringMessage() {
        return messageString;
    }
}
